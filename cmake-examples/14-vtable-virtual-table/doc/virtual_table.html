<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>The Ultimate Guide to C&plus;&plus; Virtual Tables</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="the-ultimate-guide-to-c-virtual-tables">The Ultimate Guide to C++ Virtual Tables</h1>
<p><em>A Deep Dive into the Mechanism Powering C++ Polymorphism, from Simple Inheritance to the Diamond Problem</em></p>
<hr>
<h3 id="table-of-contents"><strong>Table of Contents</strong></h3>
<ul>
<li><a href="#the-ultimate-guide-to-c-virtual-tables">The Ultimate Guide to C++ Virtual Tables</a>
<ul>
<li><a href="#table-of-contents"><strong>Table of Contents</strong></a></li>
<li><a href="#1-introduction-the-heart-of-polymorphism">1. Introduction: The Heart of Polymorphism</a></li>
<li><a href="#2-the-core-mechanism-single-inheritance-and-v-tables">2. The Core Mechanism: Single Inheritance and V-Tables</a>
<ul>
<li><a href="#the-vptr-and-the-v-table">The <code>vptr</code> and the V-Table</a></li>
<li><a href="#uml-and-memory-layout">UML and Memory Layout</a>
<ul>
<li><a href="#uml-class-diagram">UML Class Diagram</a></li>
<li><a href="#v-tables-and-object-memory-layout">V-Tables and Object Memory Layout</a></li>
</ul>
</li>
<li><a href="#dynamic-dispatch-in-action">Dynamic Dispatch in Action</a></li>
</ul>
</li>
<li><a href="#3-level-up-multiple-inheritance">3. Level Up: Multiple Inheritance</a>
<ul>
<li><a href="#memory-layout-with-multiple-v-pointers">Memory Layout with Multiple V-Pointers</a>
<ul>
<li><a href="#uml-class-diagram-1">UML Class Diagram</a></li>
<li><a href="#memory-layout-table-touchscreen-object">Memory Layout Table: <code>Touchscreen</code> Object</a></li>
</ul>
</li>
<li><a href="#casting-and-pointer-adjustment">Casting and Pointer Adjustment</a></li>
</ul>
</li>
<li><a href="#4-the-final-boss-the-diamond-problem--virtual-inheritance">4. The Final Boss: The Diamond Problem &amp; Virtual Inheritance</a>
<ul>
<li><a href="#the-problem-ambiguity-and-duplication">The Problem: Ambiguity and Duplication</a>
<ul>
<li><a href="#uml-and-memory-layout-the-problem">UML and Memory Layout (The Problem)</a></li>
</ul>
</li>
<li><a href="#the-solution-virtual-inheritance">The Solution: <code>virtual</code> Inheritance</a></li>
<li><a href="#the-v-base-offset">The V-Base Offset</a></li>
<li><a href="#memory-layout-and-casting-revisited">Memory Layout and Casting Revisited</a>
<ul>
<li><a href="#memory-layout-table-copier-with-virtual-inheritance">Memory Layout Table: <code>Copier</code> (With <code>virtual</code> Inheritance)</a></li>
<li><a href="#visualizing-the-final-layout">Visualizing the Final Layout</a></li>
</ul>
</li>
<li><a href="#casting-and-pointer-adjustment-in-diamond-inheritance"><strong>Casting and Pointer Adjustment in Diamond Inheritance</strong></a>
<ul>
<li><a href="#diamond-inheritance-with-virtual-keyword">Diamond Inheritance with <code>virtual</code> keyword</a></li>
</ul>
</li>
<li><a href="#pointer-adjustments-and-casting">Pointer Adjustments and Casting</a></li>
<li><a href="#what-g-does-internally-simplified">What g++ does internally (simplified):</a></li>
<li><a href="#example-output-on-x86_64-with-g">Example Output (on x86_64 with g++):</a></li>
<li><a href="#summary-of-casting-in-diamond-inheritance">Summary of Casting in Diamond Inheritance</a></li>
<li><a href="#notes-on-downcasting">Notes on Downcasting</a></li>
<li><a href="#rtti-for-type-casting">RTTI for type casting</a></li>
</ul>
</li>
<li><a href="#5-practical-implications-and-conclusion">5. Practical Implications and Conclusion</a>
<ul>
<li><a href="#performance-considerations">Performance Considerations</a></li>
<li><a href="#relevance-in-high-performance-domains-eg-fintech">Relevance in High-Performance Domains (e.g., FinTech)</a></li>
<li><a href="#key-takeaways">Key Takeaways</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h2 id="1-introduction-the-heart-of-polymorphism">1. Introduction: The Heart of Polymorphism</h2>
<p>In C++, <strong>polymorphism</strong> allows us to design flexible systems by treating objects of different classes in a uniform way through a common base class interface. When you call a member function on a base class pointer that points to a derived object, how does the program know <em>which</em> version of the function to execute?</p>
<p>The answer lies in one of C++'s most elegant implementation details: the <strong>Virtual Table</strong>, or <strong>V-Table</strong>. Mastering this concept is essential for any serious C++ developer, as it unlocks the true power of object-oriented design.</p>
<h2 id="2-the-core-mechanism-single-inheritance-and-v-tables">2. The Core Mechanism: Single Inheritance and V-Tables</h2>
<p>Let's start with a classic example: a <code>Shape</code> hierarchy.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// A virtual destructor is ESSENTIAL for polymorphic hierarchies.</span>
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-comment">/* draws a generic shape */</span> }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">float</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0.0f</span>; }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-comment">/* draws a circle */</span> }
    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-comment">/* returns circle area */</span> }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">float</span> radius;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-comment">/* draws a square */</span> }
    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-comment">/* returns square area */</span> }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">float</span> side;
};
</code></pre>
<h3 id="the-vptr-and-the-v-table">The <code>vptr</code> and the V-Table</h3>
<p>To enable runtime polymorphism, the compiler performs two critical actions:</p>
<ol>
<li><strong>V-Table Creation</strong>: For each class with <code>virtual</code> functions (<code>Shape</code>, <code>Circle</code>, <code>Square</code>), the compiler creates a single, static V-Table. This is a lookup table (an array of function pointers) for all virtual functions of that class.</li>
<li><strong>The V-Pointer (<code>vptr</code>)</strong>: Every object instance of these classes is endowed with a hidden member pointer, the <strong><code>vptr</code></strong>. This pointer is initialized by the constructor to point to the V-Table of the object's actual class. It's typically the very first member in the object's memory layout.</li>
</ol>
<h3 id="uml-and-memory-layout">UML and Memory Layout</h3>
<h4 id="uml-class-diagram">UML Class Diagram</h4>

<img style="background-color:#FFF;" src="https://www.plantuml.com/plantuml/svg/XP0x3i8m343tdC9ZAnI96J4KCJ7t12O9mY9DY-E0nE_iY8HAfGlhizwpvIOAigJEgtYYC21Z1yPZZ1iHfdqIjpDzQEdcOAbKda1xnC71NG4iu48i2JsyCgpg7sWPhpE4xB2grNDiROcDBp4DZ9PINC71zoXPcnJcPdjEoACPoRg_Nhbx_T3wktPAIaurBjZFDzu0"><h4 id="v-tables-and-object-memory-layout">V-Tables and Object Memory Layout</h4>
<p>The compiler generates these static tables somewhere in the program's data segment.</p>
<table>
<thead>
<tr>
<th style="text-align:left">V-Table for <code>Shape</code></th>
<th style="text-align:left">V-Table for <code>Circle</code></th>
<th style="text-align:left">V-Table for <code>Square</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&amp;Shape::~Shape</code></td>
<td style="text-align:left"><code>&amp;Circle::~Circle</code></td>
<td style="text-align:left"><code>&amp;Square::~Square</code></td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;Shape::draw</code></td>
<td style="text-align:left"><code>&amp;Circle::draw</code></td>
<td style="text-align:left"><code>&amp;Square::draw</code></td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;Shape::area</code></td>
<td style="text-align:left"><code>&amp;Circle::area</code></td>
<td style="text-align:left"><code>&amp;Square::area</code></td>
</tr>
</tbody>
</table>
<p>Now, let's visualize the memory layout of an instance of <code>Circle</code>.</p>

<img style="background-color:#FFF;" src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuSfFoafDBb5GIiuiIiv9ZSzFoh9IS0QpbHGIYw5CXMek1OMoWf8YBWM5eiIKpD9YhbekkDOmtP34f9nKXRJy8cIjOH1HaDPeWrWh1JM8d9LL7OIXeGcICKIMIIbAB8S86o4B9nQb9cfeWgo4YO3Seg2hQmUrXCiXDIy5v1i0"><p><strong>Memory Layout Table: <code>Circle</code> Object</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Offset</th>
<th style="text-align:left">Member</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+0</code></td>
<td style="text-align:left"><code>vptr</code></td>
<td style="text-align:left">Points to the <code>Circle</code> V-Table. (Size: 8 bytes on a 64-bit system)</td>
</tr>
<tr>
<td style="text-align:left"><code>+8</code></td>
<td style="text-align:left"><code>radius</code></td>
<td style="text-align:left">The data member specific to <code>Circle</code>. (Size: 4 bytes)</td>
</tr>
</tbody>
</table>
<h3 id="dynamic-dispatch-in-action">Dynamic Dispatch in Action</h3>
<p>Consider this code:</p>
<pre><code class="language-cpp">Shape* shape_ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();
shape_ptr-&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// This is where the magic happens</span>
</code></pre>
<p>This call is translated by the compiler into a sequence of operations equivalent to this:</p>
<ol>
<li><strong>Get <code>vptr</code></strong>: Access the <code>vptr</code> at the start of the object pointed to by <code>shape_ptr</code>.
<code>vptr = *(shape_ptr)</code></li>
<li><strong>Get V-Table</strong>: Dereference the <code>vptr</code> to get the address of the V-Table.
<code>v_table = *vptr</code></li>
<li><strong>Get Function Address</strong>: Get the function pointer at the known index for <code>draw()</code> (e.g., index 1).
<code>function_address = v_table[1]</code></li>
<li><strong>Call Function</strong>: Call the function at that address, passing the object's <code>this</code> pointer implicitly.
<code>call(function_address, shape_ptr)</code></li>
</ol>
<p>Because <code>shape_ptr</code> points to a <code>Circle</code> object, its <code>vptr</code> points to the <code>Circle</code> V-Table, ensuring <code>Circle::draw()</code> is called. This is <strong>dynamic dispatch</strong>.</p>
<h2 id="3-level-up-multiple-inheritance">3. Level Up: Multiple Inheritance</h2>
<p>What happens when a class inherits from multiple base classes that have virtual functions?</p>
<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputDevice</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* polls for input */</span> }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputDevice</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* renders output */</span> }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Touchscreen</span> : <span class="hljs-keyword">public</span> InputDevice, <span class="hljs-keyword">public</span> OutputDevice {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">poll</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-comment">/* touchscreen poll logic */</span> }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-comment">/* touchscreen render logic */</span> }
};
</code></pre>
<h3 id="memory-layout-with-multiple-v-pointers">Memory Layout with Multiple V-Pointers</h3>
<p>An object of a class with multiple bases will contain a subobject for each base class. If a base class has a V-Table, its subobject will contain a <code>vptr</code>.</p>
<h4 id="uml-class-diagram-1">UML Class Diagram</h4>

<img style="background-color:#FFF;" src="https://www.plantuml.com/plantuml/svg/TS-n2i9030RWFK-HKP623-1GmQMJWxx0UGruUCqTkQH3rNUNIeKJSGlyN_AJjgWJjI52kGNEJjo0FhfIzgeIBgRK-SIdC15k0Tu9TfnD3pG6JtW7n0sEGTHSn9nYNAtX-P57qtzKY7kI6f-J-MlnGiIBNSxDOyth_jsZQUfD-AhyILlYVdxs1G00"><h4 id="memory-layout-table-touchscreen-object">Memory Layout Table: <code>Touchscreen</code> Object</h4>
<p>A <code>Touchscreen</code> object contains <strong>two</strong> <code>vptr</code>s: one for each polymorphic base.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Offset</th>
<th style="text-align:left">Member</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+0</code></td>
<td style="text-align:left"><code>vptr_InputDevice</code></td>
<td style="text-align:left"><strong>(InputDevice subobject starts here)</strong> Points to the <code>Touchscreen</code> V-Table section for <code>InputDevice</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>+8</code></td>
<td style="text-align:left"><code>vptr_OutputDevice</code></td>
<td style="text-align:left"><strong>(OutputDevice subobject starts here)</strong> Points to the <code>Touchscreen</code> V-Table section for <code>OutputDevice</code>.</td>
</tr>
</tbody>
</table>
<h3 id="casting-and-pointer-adjustment">Casting and Pointer Adjustment</h3>
<p>This layout has a critical implication for casting:</p>
<ul>
<li>A <code>Touchscreen*</code> cast to an <code>InputDevice*</code> requires no change in the pointer's value.</li>
<li>A <code>Touchscreen*</code> cast to an <code>OutputDevice*</code> requires the pointer value to be adjusted by <code>+8</code> bytes to point to the start of the <code>OutputDevice</code> subobject. This adjustment is known as a <strong>thunk</strong>.</li>
</ul>
<!-- end list -->
<pre><code class="language-cpp">Touchscreen* ts = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Touchscreen</span>();
InputDevice* in_ptr = ts;   <span class="hljs-comment">// in_ptr == ts</span>
OutputDevice* out_ptr = ts; <span class="hljs-comment">// out_ptr == (char*)ts + 8</span>
</code></pre>
<h2 id="4-the-final-boss-the-diamond-problem--virtual-inheritance">4. The Final Boss: The Diamond Problem &amp; Virtual Inheritance</h2>
<p>This is the most complex scenario, where a class inherits from two bases that share a common ancestor.</p>
<h3 id="the-problem-ambiguity-and-duplication">The Problem: Ambiguity and Duplication</h3>
<pre><code class="language-cpp"><span class="hljs-comment">// Without virtual inheritance</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PoweredDevice</span> { <span class="hljs-keyword">public</span>: <span class="hljs-type">bool</span> is_on; };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> : <span class="hljs-keyword">public</span> PoweredDevice { <span class="hljs-comment">/*...*/</span> };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> : <span class="hljs-keyword">public</span> PoweredDevice { <span class="hljs-comment">/*...*/</span> };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Copier</span> : <span class="hljs-keyword">public</span> Scanner, <span class="hljs-keyword">public</span> Printer { <span class="hljs-comment">/*...*/</span> };
</code></pre>
<h4 id="uml-and-memory-layout-the-problem">UML and Memory Layout (The Problem)</h4>

<img style="background-color:#FFF;" src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpimhI2nAp5L8paaiBdOiAIdAJ2ejIVLCpiyBpgnALJ3W0aie1EINfnQbfhYabcKcfqB5WfCJy_9IYs0gYZBpIk0yv_o2pDGYBXHj2ZOrkhfmNLYaO4P0bK04OIP1v53475BpKa2-0000"><p>An object of <code>Copier</code> would contain <strong>two separate</strong> <code>PoweredDevice</code> subobjects, leading to:</p>
<ol>
<li><strong>Ambiguity</strong>: <code>copier.is_on</code> is a compile-time error. Which <code>is_on</code>?</li>
<li><strong>State Duplication</strong>: The copier logically has one power state, but the object has two.</li>
</ol>
<p><strong>Memory Layout Table: <code>Copier</code> (Problematic)</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Offset</th>
<th style="text-align:left">Subobject / Member</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+0</code></td>
<td style="text-align:left"><code>Scanner</code> subobject</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>+0</code></td>
<td style="text-align:left"><code>PoweredDevice</code> (from <code>Scanner</code>)</td>
<td style="text-align:left">First copy of <code>is_on</code></td>
</tr>
<tr>
<td style="text-align:left">...</td>
<td style="text-align:left"><code>Printer</code> subobject</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">...</td>
<td style="text-align:left"><code>PoweredDevice</code> (from <code>Printer</code>)</td>
<td style="text-align:left">Second copy of <code>is_on</code></td>
</tr>
</tbody>
</table>
<h3 id="the-solution-virtual-inheritance">The Solution: <code>virtual</code> Inheritance</h3>
<p>The <code>virtual</code> keyword on an inheritance relationship tells the compiler to ensure only one instance of that base exists.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PoweredDevice</span> { <span class="hljs-comment">/*...*/</span> };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> PoweredDevice { <span class="hljs-comment">/*...*/</span> };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> PoweredDevice { <span class="hljs-comment">/*...*/</span> };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Copier</span> : <span class="hljs-keyword">public</span> Scanner, <span class="hljs-keyword">public</span> Printer { <span class="hljs-comment">/*...*/</span> };
</code></pre>
<h3 id="the-v-base-offset">The V-Base Offset</h3>
<p>To manage the single, shared <code>PoweredDevice</code> subobject, the compiler changes the memory layout drastically. The shared base is typically placed at the end of the object. To find it from a <code>Scanner*</code> or <code>Printer*</code>, the compiler uses a <strong>v-base offset</strong> stored in or near the V-Table.</p>
<h3 id="memory-layout-and-casting-revisited">Memory Layout and Casting Revisited</h3>
<h4 id="memory-layout-table-copier-with-virtual-inheritance">Memory Layout Table: <code>Copier</code> (With <code>virtual</code> Inheritance)</h4>
<table>
<thead>
<tr>
<th style="text-align:left">Offset</th>
<th style="text-align:left">Member</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+0</code></td>
<td style="text-align:left"><code>vptr_Scanner</code></td>
<td style="text-align:left"><strong>(Scanner subobject)</strong> Points to V-Table for <code>Copier</code>, contains <strong>v-base offset</strong> to find <code>PoweredDevice</code>.</td>
</tr>
<tr>
<td style="text-align:left">...</td>
<td style="text-align:left"><code>Scanner</code> data members</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">...</td>
<td style="text-align:left"><code>vptr_Printer</code></td>
<td style="text-align:left"><strong>(Printer subobject)</strong> Points to V-Table for <code>Copier</code>, contains <strong>v-base offset</strong> to find <code>PoweredDevice</code>.</td>
</tr>
<tr>
<td style="text-align:left">...</td>
<td style="text-align:left"><code>Printer</code> data members</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">...</td>
<td style="text-align:left"><code>Copier</code> data members</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>+N</code></td>
<td style="text-align:left"><code>PoweredDevice</code> subobject</td>
<td style="text-align:left"><strong>The single, shared instance.</strong></td>
</tr>
</tbody>
</table>
<h4 id="visualizing-the-final-layout">Visualizing the Final Layout</h4>

<img style="background-color:#FFF;" src="https://www.plantuml.com/plantuml/svg/VSzD2i8m40NW_PpYqNthNaefw04AFK38puWfcfH9MXVYtKNJZHJSFPZtyPW-PIrvkTyecebjHcNZx5bKDDCHfs-keDCMyIIWDTreTGWiI8ifhZsOZe1rpg8kKLGg1GAQfY6WhWiSn8Vy3ywbi8FRljDPR-JtFbwriCCG7opiphnwoxiLdrGCzAAUW_ly_0O0"><h3 id="casting-and-pointer-adjustment-in-diamond-inheritance"><strong>Casting and Pointer Adjustment in Diamond Inheritance</strong></h3>
<p>Let’s explore <strong>how <code>g++</code> handles upcasting and downcasting</strong> when dealing with <strong>virtual inheritance</strong>, particularly in the <strong>diamond problem</strong>.</p>
<h4 id="diamond-inheritance-with-virtual-keyword">Diamond Inheritance with <code>virtual</code> keyword</h4>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ cout &lt;&lt; <span class="hljs-string">&quot;Base\n&quot;</span>; }
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Left</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ cout &lt;&lt; <span class="hljs-string">&quot;Left\n&quot;</span>; }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Right</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ cout &lt;&lt; <span class="hljs-string">&quot;Right\n&quot;</span>; }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span> : <span class="hljs-keyword">public</span> Left, <span class="hljs-keyword">public</span> Right {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ cout &lt;&lt; <span class="hljs-string">&quot;Bottom\n&quot;</span>; }
};
</code></pre>
<p>In this classic <strong>diamond</strong>, <code>Bottom</code> inherits <code>Base</code> <strong>virtually</strong> through both <code>Left</code> and <code>Right</code>, meaning there's only <strong>one shared <code>Base</code> subobject</strong> in memory.</p>
<h3 id="pointer-adjustments-and-casting">Pointer Adjustments and Casting</h3>
<p>Let’s add code to examine casting behavior:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Bottom b;
    Base* basePtr = &amp;b; <span class="hljs-comment">// Upcast to virtual base</span>
    basePtr-&gt;<span class="hljs-built_in">who</span>();      <span class="hljs-comment">// Output: Bottom</span>

    Left* lptr = &amp;b;
    Right* rptr = &amp;b;

    cout &lt;&lt; <span class="hljs-string">&quot;lptr:  &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(lptr) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;rptr:  &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(rptr) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;base:  &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(basePtr) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;

    Base* via_left = lptr;
    Base* via_right = rptr;

    cout &lt;&lt; <span class="hljs-string">&quot;via_left Base*:  &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(via_left) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;via_right Base*: &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(via_right) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
}
</code></pre>
<h3 id="what-g-does-internally-simplified">What g++ does internally (simplified):</h3>
<ul>
<li><code>Bottom</code> has only <strong>one <code>Base</code> vptr</strong>, located at a shared location because of <strong>virtual inheritance</strong>.</li>
<li>Both <code>Left</code> and <code>Right</code> <strong>contain a pointer or offset</strong> to the shared <code>Base</code> subobject.</li>
<li>When converting <code>Left*</code> or <code>Right*</code> to <code>Base*</code>, the compiler <strong>performs a pointer adjustment</strong> to find the actual <code>Base</code> inside <code>Bottom</code>.</li>
</ul>
<h3 id="example-output-on-x86_64-with-g">Example Output (on x86_64 with g++):</h3>
<pre><code>Bottom
lptr:  0x7ffee5fbfbc0
rptr:  0x7ffee5fbfbc8
base:  0x7ffee5fbfbd0
via_left Base*:  0x7ffee5fbfbd0
via_right Base*: 0x7ffee5fbfbd0
</code></pre>
<blockquote>
<p>Notice how both <code>lptr</code> and <code>rptr</code> have different addresses, but after converting to <code>Base*</code>, both point to the <strong>same virtual base subobject</strong>.</p>
</blockquote>
<hr>
<h3 id="summary-of-casting-in-diamond-inheritance">Summary of Casting in Diamond Inheritance</h3>
<table>
<thead>
<tr>
<th>Cast Type</th>
<th>Action by <code>g++</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Bottom* -&gt; Base*</code></td>
<td>Pointer is adjusted to the virtual <code>Base</code> subobject.</td>
</tr>
<tr>
<td><code>Left* -&gt; Base*</code> or <code>Right* -&gt; Base*</code></td>
<td>Uses virtual base offset to reach shared <code>Base</code>.</td>
</tr>
<tr>
<td><code>Base* -&gt; Left*</code></td>
<td>Requires RTTI or unsafe cast (via <code>dynamic_cast</code> or <code>reinterpret_cast</code>) and reverse offset logic.</td>
</tr>
<tr>
<td><code>Left* &lt;-&gt; Right*</code></td>
<td>Not directly convertible without going through <code>Bottom*</code>.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="notes-on-downcasting">Notes on Downcasting</h3>
<pre><code class="language-cpp">Base* base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bottom</span>();
Bottom* bottom = <span class="hljs-built_in">dynamic_cast</span>&lt;Bottom*&gt;(base);
<span class="hljs-keyword">if</span> (bottom) bottom-&gt;<span class="hljs-built_in">who</span>();  <span class="hljs-comment">// Safe downcast with RTTI</span>
</code></pre>
<ul>
<li><code>dynamic_cast</code> safely handles pointer adjustments by using RTTI and the complete object layout.</li>
<li><code>reinterpret_cast</code> does <strong>not</strong> adjust pointers and can cause undefined behavior in this context.</li>
</ul>
<h3 id="rtti-for-type-casting">RTTI for type casting</h3>
<p>Run-Time Type Information (RTTI) in C++ provides a mechanism to determine the type of an object during program execution. The <code>dynamic_cast</code> operator is the primary tool that leverages RTTI to perform safe downcasting and cross-casting within a polymorphic class hierarchy.</p>
<p>Here's how <code>dynamic_cast</code> typically works with RTTI:</p>
<ol>
<li>
<p><strong>Polymorphic Requirement:</strong> <code>dynamic_cast</code> can only be used with polymorphic types, meaning the class must have at least one virtual function. This is because the presence of virtual functions ensures that each object instance has a <code>vptr</code> (virtual pointer) that points to its class's V-Table. The V-Table, in turn, contains the necessary RTTI.</p>
</li>
<li>
<p><strong>RTTI Data in V-Table:</strong> Alongside the pointers to virtual functions, the V-Table (or a related data structure pointed to by an entry in the V-Table) stores additional RTTI. This RTTI includes information about the class itself, its base classes, and their relationships. This data is specific to each class.</p>
</li>
<li>
<p><strong>Runtime Check:</strong> When you use <code>dynamic_cast&lt;TargetType*&gt;(source_ptr)</code>, the compiler generates code that:</p>
<ul>
<li>Retrieves the <code>vptr</code> from the <code>source_ptr</code> to find the object's actual (dynamic) type information.</li>
<li>Compares the dynamic type of the object pointed to by <code>source_ptr</code> with the <code>TargetType</code>. This comparison involves traversing the inheritance hierarchy using the RTTI data.</li>
<li>If the <code>source_ptr</code> points to an object of <code>TargetType</code> or a type derived from <code>TargetType</code>, the cast is successful.</li>
<li>If the cast is valid but requires a pointer adjustment (as seen in multiple or virtual inheritance, where the target subobject might not be at the same memory address as the <code>source_ptr</code>), <code>dynamic_cast</code> calculates and applies this offset. This adjustment is sometimes referred to as a &quot;thunk.&quot;</li>
</ul>
</li>
<li>
<p><strong>Result on Success/Failure:</strong></p>
<ul>
<li><strong>Pointers:</strong> If the cast is successful, <code>dynamic_cast</code> returns a valid pointer to the <code>TargetType</code> subobject. If the cast fails (meaning the object is not of the <code>TargetType</code> or a derived type), it returns a <code>nullptr</code>.</li>
<li><strong>References:</strong> If <code>dynamic_cast</code> is used with references (<code>dynamic_cast&lt;TargetType&amp;&gt;(source_ref)</code>), and the cast fails, it throws a <code>std::bad_cast</code> exception.</li>
</ul>
</li>
</ol>
<p><strong>Key Aspects of RTTI in <code>dynamic_cast</code>:</strong></p>
<ul>
<li><strong>Downcasting and Cross-casting:</strong> <code>dynamic_cast</code> is primarily used for downcasting (casting a base class pointer/reference to a derived class pointer/reference) and cross-casting (casting between two unrelated derived classes that share a common polymorphic base).</li>
<li><strong>Safety:</strong> Unlike <code>static_cast</code> or <code>reinterpret_cast</code>, <code>dynamic_cast</code> provides runtime safety by verifying the type before performing the conversion. This prevents undefined behavior that could arise from an invalid cast.</li>
<li><strong>Overhead:</strong> The runtime check and potential pointer adjustments incur a slight performance overhead compared to compile-time casts. For this reason, <code>dynamic_cast</code> is typically used when the exact type of an object is not known at compile time and needs to be determined dynamically.</li>
</ul>
<p>In essence, RTTI empowers <code>dynamic_cast</code> to make intelligent decisions at runtime about the validity and necessary adjustments for type conversions within a polymorphic hierarchy.</p>
<p>To learn more about dynamic casting and RTTI in C++, you can watch this video: <a href="https://www.youtube.com/watch?v=2PXN7Zk9v80">Dynamic cast c++ Runtime Type Identification example why we use dynamic cast - RTTI</a>.
<a href="http://googleusercontent.com/youtube_content/0">http://googleusercontent.com/youtube_content/0</a></p>
<h2 id="5-practical-implications-and-conclusion">5. Practical Implications and Conclusion</h2>
<h3 id="performance-considerations">Performance Considerations</h3>
<ul>
<li><strong>Memory:</strong> Each polymorphic object has an overhead of one <code>vptr</code> (or more in multiple inheritance).</li>
<li><strong>Speed:</strong> A virtual function call involves a few extra memory lookups and an indirect call, making it slightly slower than a direct call. This cost is usually negligible but can be a factor in tight performance-critical loops.</li>
</ul>
<h3 id="relevance-in-high-performance-domains-eg-fintech">Relevance in High-Performance Domains (e.g., FinTech)</h3>
<p>In FinTech, systems must be precise, performant, and highly extensible. The principles of polymorphism are critical for building robust trading, risk, and compliance systems.</p>
<p>Consider a system for pricing financial instruments. You might have a base class <code>TradableAsset</code> with a virtual function <code>double getCurrentValue() const</code>. Derived classes could be <code>Stock</code>, <code>Bond</code>, <code>Option</code>, and <code>Future</code>. A portfolio can hold a <code>std::vector&lt;TradableAsset*&gt;</code> and calculate its total value by calling <code>getCurrentValue()</code> on each element. Thanks to the V-Table, the correct, highly-specialized pricing logic is invoked for each asset. This allows the system to be easily extended with new financial products without modifying the core portfolio logic—a crucial feature in a fast-evolving financial landscape.</p>
<h3 id="key-takeaways">Key Takeaways</h3>
<blockquote>
<ul>
<li><strong>Polymorphism is powered by V-Tables and <code>vptr</code>s.</strong></li>
<li>Every object of a polymorphic class has a hidden <code>vptr</code> pointing to its class's V-Table.</li>
<li>A virtual function call is an indirect call resolved at runtime (<strong>dynamic dispatch</strong>).</li>
<li><strong>Always declare a virtual destructor</strong> in polymorphic base classes.</li>
<li>Multiple inheritance adds multiple <code>vptr</code>s to an object's layout.</li>
<li>The <strong>Diamond Problem</strong> (ambiguity and duplication) is solved by <strong><code>virtual</code> inheritance</strong>.</li>
<li>Virtual inheritance uses <strong>v-base offsets</strong> to locate the shared base subobject, making the memory layout more complex and introducing runtime costs for certain casts.</li>
</ul>
</blockquote>

            
            
        </body>
        </html>